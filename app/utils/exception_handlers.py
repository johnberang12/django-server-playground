import logging
from rest_framework import status
from rest_framework.views import exception_handler
from rest_framework.response import Response
import traceback
from django.conf import settings


# Setup logger
logger = logging.getLogger(__name__)


def custom_exception_handler(exc, context):
    # Call DRF's default exception handler first to get the standard error response.
    response = exception_handler(exc, context)

    # If a response was generated by DRF's default exception handler, customize its format.
    if response is not None:
        # Log the error for backend diagnosis
        logger.error(
            "API Error: %s %s. Status: %s. Data: %s",
            context["request"].method,
            context["request"].path,
            response.status_code,
            response.data,
        )

        # Add a stack trace if we're in DEBUG mode
        if settings.DEBUG:
            trace = traceback.format_exception(
                etype=type(exc), value=exc, tb=exc.__traceback__
            )
            stack_trace = "".join(trace)
        else:
            stack_trace = None  # Set to None if not in DEBUG mode. You can choose to omit it altogether if preferred.

        detailed_info = response.data
        if "detail" in detailed_info:
            del detailed_info["detail"]

        customized_data = {
            "status_code": response.status_code,
            "error_code": str(response.data.get("code", "UNKNOWN_ERROR")),
            "message": str(response.data.get("detail", "Unknown error occurred.")),
            "details": detailed_info,
            "links": {
                "documentation": "https://example.com/docs/errors/"
                + str(response.data.get("code", "UNKNOWN_ERROR"))
            },
        }

        if stack_trace:  # Add the stack trace field only if it's present.
            customized_data["stack_trace"] = stack_trace

        # Override the default response data with your customized data.
        response.data = customized_data

    else:
        # Handle exceptions that are not handled by the DRF's default exception handler
        # Log the error for backend diagnosis
        logger.error(
            "Unhandled Error: %s %s. Exception: %s",
            context["request"].method,
            context["request"].path,
            exc,
        )

        # You can customize this message as you see fit.
        response = Response(
            {
                "status_code": status.HTTP_500_INTERNAL_SERVER_ERROR,
                "error_code": "INTERNAL_SERVER_ERROR",
                "message": "An internal server error occurred. Our team has been notified.",
                "details": {},
                "links": {
                    "documentation": "https://example.com/docs/errors/INTERNAL_SERVER_ERROR"
                },
            },
            status=status.HTTP_500_INTERNAL_SERVER_ERROR,
        )

    return response


#######  Example of use  ######
# Setting error
# raise exceptions.AuthenticationFailed({
#     'detail': 'The password is incorrect.',
#     'code': 'wrong-password'
# })


# Error catched
# {
#     "status_code": 401,
#     "error_code": "wrong-password",
#     "message": "The password is incorrect.",
#     "details": {},
#     "links": {
#         "documentation": "https://example.com/docs/errors/wrong-password"
#     }
# }
